#!/usr/bin/perl -w
#!/usr/bin/perl -d:ptkdb -w
#

use strict;


BEGIN
{
    #! make check

    push @INC, '../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';
}


use Getopt::Long;

use Neurospaces;
use Neurospaces::Traversal;
use Neurospaces::Studio;


my $global_operators
    = {
       average =>
       sub
       {
	   my ($description, $final_value, $context, $parameter, $value) = @_;

	   my $count = 0;

	   if (defined $description)
	   {
	       $description =~ /([0-9]+)/;

	       $count = $1;
	   }

	   $count++;

	   !defined $final_value && $final_value = 0;

	   return ("average of $count value(s)", $final_value + $value / $count);
       },
       cumulate =>
       sub
       {
	   my ($description, $final_value, $context, $parameter, $value) = @_;

	   return ('cumulated value', ($final_value || 0) + $value);
       },
       maximum =>
       sub
       {
	   my ($description, $final_value, $context, $parameter, $value) = @_;

	   !defined $final_value && return("$context->$parameter", $value);

	   return $final_value >= $value ? ($description, $final_value) : ("$context->$parameter", $value);
       },
       minimum =>
       sub
       {
	   my ($description, $final_value, $context, $parameter, $value) = @_;

	   !defined $final_value && return("$context->$parameter", $value);

	   return $final_value <= $value ? ($description, $final_value) : ("$context->$parameter", $value);
       },
      };

my $operator_results = {};


use Data::Dumper;


# {
#     no strict "refs";

#     print Dumper(\%{"main::"});

#     print "Found these methods for Neurospaces::\n";

#     print Dumper(\%{"Neurospaces::"});

#     print "Found these methods for Neurospaces::Traversal::\n";

#     print Dumper(\%{"Neurospaces::Traversal::"});

#     print "Found these methods for SwiggableNeurospaces::\n";

#     print Dumper(\%{"SwiggableNeurospaces::"});

#     print "Found these methods for SwiggableNeurospaces::PidinStack::\n";

#     print Dumper(\%{"SwiggableNeurospaces::PidinStack::"});

#     print "Found these methods for SwiggableNeurospaces::descr_Segment::\n";

#     print Dumper(\%{"SwiggableNeurospaces::descr_Segment::"});

#     print "Found these methods for SwiggableNeurospaces::symtab_Segment::\n";

#     print Dumper(\%{"SwiggableNeurospaces::symtab_Segment::"});

#     print "Found these methods for SwiggableNeurospaces::symtab_BioComponent::\n";

#     print Dumper(\%{"SwiggableNeurospaces::symtab_BioComponent::"});

#     print "Found these methods for SwiggableNeurospaces::Symbols::\n";

#     print Dumper(\%{"SwiggableNeurospaces::Symbols::"});

# }


# use Neurospaces_embed;


BEGIN
{
    $SIG{__DIE__}
	= sub {
	    use Carp;

	    confess @_;
	};
}


my $option_algorithm;
my $option_condition = [];
my $option_force_library;
my $option_gui;
my $option_interactive;
my $option_models = '/usr/local/neurospaces/models/library';
my $option_no_use_library;
my $option_operators = [];
my $option_querymachine;
my $option_render = [];
my $option_reporting_fields = [];
my $option_scaling;
my $option_shrinkage_correction;
my $option_spine_prototypes = [];
my $option_traversal_symbol;
my $option_type;
my $option_verbose;


sub main
{
    read_cmd_line();

    my $neurospaces = Neurospaces->new();

    # my $args = [ "$0", "-P", "-q", "cells/golgi.ndf" ];

    my $args = [ "$0", "-P", ];

    if ($option_models)
    {
	$ENV{NEUROSPACES_MODELS} = $option_models;
    }

    if ($option_querymachine)
    {
	push @$args, '-q';
    }

#     push @$args, @ARGV;

    my $success
	= $neurospaces->load
	    (
	     {
	      'force-library' => $option_force_library,
	      'filename' => $ARGV[0],
	      (defined $option_no_use_library) ? ('no-use-library' => $option_no_use_library) : (),
	      (defined $option_shrinkage_correction) ? ('shrinkage' => $option_shrinkage_correction) : (),
	      'spine-prototypes' => $option_spine_prototypes,
	     },
	     $args,
	    );

    if ($option_interactive)
    {
	#t not sure yet, should be perhaps based on the perl shell ?
    }

    # load additional data to render before opening the gui

    if (@$option_render)
    {
	require Neurospaces::GUI::Tools::Renderer::External;

	foreach my $external (@$option_render)
	{
	    Neurospaces::GUI::Tools::Renderer::External::load($external);
	}
    }

    if ($option_gui)
    {
	require Neurospaces::GUI;
	Neurospaces::GUI::gui($0);
    }

#     my $renderer = $Neurospaces::Studio::renderer;

#     if ($renderer)
#     {
# 	$renderer->start();
#     }

    # from here on, go through the options alphabetically

    if ($option_algorithm)
    {
	$neurospaces->algorithm_instance_report($option_algorithm);
    }

    if ($option_traversal_symbol)
    {
	my $symbol;
	my $parameters = [];
	my $operator_names = [];

	#! never use this functionality, avoid shell quoting issues,
	#! use the field options instead.

	if (0 && $option_traversal_symbol =~ /^([^-]+)->(.+)$/)
	{
	    $symbol = $1;
	    $parameters = [ $2, ];
	}
	else
	{
	    $symbol = $option_traversal_symbol;
	}

	if (@$option_reporting_fields)
	{
	    $parameters = $option_reporting_fields;
	}

	if (@$option_operators)
	{
	    $operator_names = $option_operators;
	}

	my $traversal
	    = Neurospaces::Traversal->new
		(
		 {
		  context => $symbol,
		  processor =>
		  sub
		  {
		      my $self = shift;

		      my $descendant = shift;

		      my $d = $descendant;

		      if ($option_type)
		      {
			  if ($descendant->{type} !~ /$option_type/)
			  {
			      return 1;
			  }
		      }

		      if (@$option_condition)
		      {
			  foreach my $condition (@$option_condition)
			  {
			      my $value = eval $condition;

			      if ($@)
			      {
				  die $@;
			      }

			      if (!$value)
			      {
				  return 1;
			      }
			  }
		      }

		      if (@$parameters)
		      {
			  foreach my $parameter (@$parameters)
			  {
			      my $value;

			      if ($option_scaling)
			      {
				  $value
				      = SwiggableNeurospaces::symbol_parameter_resolve_scaled_value
					  (
					   $descendant->{_symbol},
					   $parameter,
					   $descendant->{_context}
					  );
			      }
			      else
			      {
				  $value
				      = SwiggableNeurospaces::symbol_parameter_resolve_value
					  (
					   $descendant->{_symbol},
					   $parameter,
					   $descendant->{_context}
					  );
			      }

			      if (@$operator_names)
			      {
				  foreach my $operator_name (@$operator_names)
				  {
				      my $operator = $global_operators->{$operator_name};

				      if (!defined $operator)
				      {
					  die "$0: $operator_name is not defined";
				      }

				      if (ref $operator eq 'CODE')
				      {
					  my $description = $operator_results->{$operator_name}->{description};
					  my $final_value = $operator_results->{$operator_name}->{final_value};

					  ($description, $final_value) = &$operator($description, $final_value, $descendant->{context}, $parameter, $value);

					  if (!defined $final_value)
					  {
					      die "$0: $operator_name returned an error condition";
					  }

					  $operator_results->{$operator_name}->{description} = $description;
					  $operator_results->{$operator_name}->{final_value} = $final_value;
				      }
				      else
				      {
					  die "$0: $operator_name is not a CODE reference";
				      }
				  }
			      }
			      else
			      {
				  if ($value != $SwiggableNeurospaces::dFLT_MAX)
				  {
				      print $descendant->{context} . "->" . $parameter . " = " . $value . "\n";
				  }
			      }
			  }
		      }
		      else
		      {
			  print "$descendant->{context}\n";
		      }

		      return 1;
		  },
		  neurospaces => $neurospaces,
		 },
		);

	my $success = $traversal->go();

	if (!$success)
	{
	    print "Traversal failed\n";
	}
	else
	{
	    if (@$operator_names)
	    {
		foreach my $operator_name (sort @$operator_names)
		{
		    my $description = $operator_results->{$operator_name}->{description};
		    my $final_value = $operator_results->{$operator_name}->{final_value};

		    print "$operator_name:
  description: $description
  final_value: $final_value\n";
		}
	    }

	    print STDERR "Traversal ok\n";
	}
    }


}


sub read_cmd_line
{
    my $option_help;

    my $result
	= GetOptions
	    (
	     "algorithm=s" => \$option_algorithm,
	     "condition=s" => $option_condition,
	     "force-library!" => \$option_force_library,
	     "gui!" => \$option_gui,
	     "help!" => \$option_help,
	     "interactive!" => \$option_interactive,
	     "models=s" => \$option_models,
	     "no-use-library!" => \$option_no_use_library,
	     "operators=s" => $option_operators,
	     "query!" => \$option_querymachine,
	     "reporting-fields=s" => $option_reporting_fields,
	     "render=s" => $option_render,
	     "scaling!" => \$option_scaling,
	     "shrinkage-correction=s" => \$option_shrinkage_correction,
	     "spine-prototypes=s" => $option_spine_prototypes,
	     "traversal-symbol=s" => \$option_traversal_symbol,
	     "type=s" => \$option_type,
	     "v|verbose+" => \$option_verbose,
	    );

    if ($option_help || @ARGV eq 0)
    {
	print
	    "
$0 <model-filename>

$0: parse a model description, interact with the model.

options :
    algorithm              report on an algorithm instance.
    condition              a (perl) condition to apply, where applicable.
    cumulate               accumulate field values, then final report.
    force-library          force the use of library values for morphology2ndf.
    gui                    enter the gui.
    help                   print usage information.
    interactive            enter interactive mode.
    models                 directory where to find the neurospaces library (default is $option_models).
    no-use-library         do not use the library with specific settings for each morphology.
    operators              apply these operators to each reported field.
    query                  enter the query machine after parsing.
    reporting-fields       report these fields during traversing (use multiple options to report multiple fields).
    render                 render a file, using a renderer plugin.
    scaling                apply scaling to the reported parameter values,
                           can be used in combination with cumulate.
    shrinkage-correction   shrinkage correction
                           NOTE: this is only applied when loading files that need conversion,
                           it is not applied when reading ndf files.
    spine-prototypes       add spines with this prototype
    traversal-symbol       symbol to traverse.
    type                   type to traverse
    verbose                set verbosity level.
";

	exit 1;
    }
}


main();


